package historicalspeed

import (
	"reflect"
	"strings"
	"testing"
	"time"
)

func TestQuerySpeedOnDailyPattern(t *testing.T) {

	pattern := make(dailyPattern, patternsPerDay)
	for i := 0; i < patternsPerDay; i++ {
		pattern[i] = uint8(i + 1) // 1,2,3,...,96
	}

	cases := []struct {
		t     time.Time
		speed uint8
	}{
		{time.Date(2020, time.March, 30, 0, 0, 0, 0, time.UTC), 1},
		{time.Date(2020, time.March, 30, 0, 14, 59, 0, time.UTC), 1},
		{time.Date(2020, time.March, 30, 0, 15, 00, 0, time.UTC), 2},
		{time.Date(2020, time.March, 30, 23, 44, 59, 0, time.UTC), 95},
		{time.Date(2020, time.March, 30, 23, 45, 00, 0, time.UTC), 96},
		{time.Date(2020, time.March, 30, 23, 59, 59, 0, time.UTC), 96},
	}

	for _, c := range cases {
		speed := pattern.querySpeed(c.t)
		if speed != c.speed {
			t.Errorf("Query speed on time %s, expect %d but got %d", c.t, c.speed, speed)
		}
	}
}

func TestParseDailyPatternRecordFailure(t *testing.T) {
	cases := [][]string{
		strings.Split("PATTERN_ID,H00_00,H00_15,H00_30,H00_45,H01_00,H01_15,H01_30,H01_45,H02_00,H02_15,H02_30,H02_45,H03_00,H03_15,H03_30,H03_45,H04_00,H04_15,H04_30,H04_45,H05_00,H05_15,H05_30,H05_45,H06_00,H06_15,H06_30,H06_45,H07_00,H07_15,H07_30,H07_45,H08_00,H08_15,H08_30,H08_45,H09_00,H09_15,H09_30,H09_45,H10_00,H10_15,H10_30,H10_45,H11_00,H11_15,H11_30,H11_45,H12_00,H12_15,H12_30,H12_45,H13_00,H13_15,H13_30,H13_45,H14_00,H14_15,H14_30,H14_45,H15_00,H15_15,H15_30,H15_45,H16_00,H16_15,H16_30,H16_45,H17_00,H17_15,H17_30,H17_45,H18_00,H18_15,H18_30,H18_45,H19_00,H19_15,H19_30,H19_45,H20_00,H20_15,H20_30,H20_45,H21_00,H21_15,H21_30,H21_45,H22_00,H22_15,H22_30,H22_45,H23_00,H23_15,H23_30,H23_45", ","),
		strings.Split("0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,", ","),    // too less field
		strings.Split("0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", ","), // too many fields
		strings.Split("a,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", ","),   // char instead of integer on patternID
		strings.Split("0,a,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", ","),   // char instead of integer on speed
		strings.Split("-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", ","),  // negative patternID
		strings.Split("0,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", ","),  // negative speed
		strings.Split("0,256,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", ","), // speed overflow
	}

	for _, c := range cases {
		_, _, err := parseDailyPatternRecord(c)
		if err == nil {
			t.Errorf("expect parse %v failed but got succeed", c)
		}
	}
}

func TestParseDailyPatternRecordSucceed(t *testing.T) {
	cases := []struct {
		record    []string
		patternID uint32
		dailyPattern
	}{
		{
			strings.Split("0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1", ","),
			0,
			dailyPattern{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
		},
		{
			strings.Split("15181,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,99,89,68,61,61,60,60,60,59,59,60,60,60,60,61,61,62,63,64,65,66,67,68,69,70,72,73,74,75,77,78,79,80,80,81,81,82,82,82,82,82,82,81,81,81,81,80,80,80,79,79,79,79,78,78,78,78,78,78,79,80,82,86,93,97,99,100", ","),
			15181,
			dailyPattern{100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 99, 89, 68, 61, 61, 60, 60, 60, 59, 59, 60, 60, 60, 60, 61, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 72, 73, 74, 75, 77, 78, 79, 80, 80, 81, 81, 82, 82, 82, 82, 82, 82, 81, 81, 81, 81, 80, 80, 80, 79, 79, 79, 79, 78, 78, 78, 78, 78, 78, 79, 80, 82, 86, 93, 97, 99, 100},
		},
	}

	for _, c := range cases {
		id, pattern, err := parseDailyPatternRecord(c.record)
		if err != nil {
			t.Errorf("expect parse %v succeed but got err %v", c.record, err)
		}
		if id != c.patternID {
			t.Errorf("parse %v, expect patternID %d but got %d", c.record, c.patternID, id)
		}
		if !reflect.DeepEqual(pattern, c.dailyPattern) {
			t.Errorf("parse %v, expect pattern %v but got %v", c.record, c.dailyPattern, pattern)
		}

	}
}
