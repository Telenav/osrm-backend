package osrmtype

import (
	"reflect"
	"testing"
)

func TestNBGToEBGsWrite(t *testing.T) {
	cases := []struct {
		p []byte
		NBGToEBGs
	}{
		{
			[]byte{0x0f, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x63, 0x05, 0x00},
			NBGToEBGs{{U: 15, V: 671551, ForwardEBGNode: 0, BackwardEBGNode: 353067}},
		},
		{
			[]byte{
				0x0f, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x63, 0x05, 0x00,
				0xff, // redundant byte
			},
			NBGToEBGs{{U: 15, V: 671551, ForwardEBGNode: 0, BackwardEBGNode: 353067}},
		},
		{
			[]byte{
				0x0f, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x63, 0x05, 0x00,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // redundant bytes
			},
			NBGToEBGs{{U: 15, V: 671551, ForwardEBGNode: 0, BackwardEBGNode: 353067}},
		},
		{
			[]byte{
				0x0f, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x63, 0x05, 0x00,
				0x3f, 0x3f, 0x08, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x74, 0x1a, 0x04, 0x00, 0x3f, 0x3f, 0x3f, 0x3f,
			},
			NBGToEBGs{
				{U: 15, V: 671551, ForwardEBGNode: 0, BackwardEBGNode: 353067},
				{U: 540479, V: 15, ForwardEBGNode: 268916, BackwardEBGNode: 1061109567},
			},
		},
	}

	for _, c := range cases {
		var nbgToEBGs NBGToEBGs
		_, err := nbgToEBGs.Write(c.p)
		if err != nil {
			t.Error(err)
		}
		if !reflect.DeepEqual(nbgToEBGs, c.NBGToEBGs) {
			t.Errorf("construct NBGToEBG from %v, expect %v, but got %v", c.p, c.NBGToEBGs, nbgToEBGs)
		}
	}
}
