package topoquerier

import (
	"sort"

	"github.com/Telenav/osrm-backend/integration/api/nav"
	"github.com/Telenav/osrm-backend/integration/service/oasis/internal/entity"
	"github.com/Telenav/osrm-backend/integration/service/oasis/place"
	"github.com/Telenav/osrm-backend/integration/service/oasis/place/iterator/iteratortype"
	"github.com/Telenav/osrm-backend/integration/service/oasis/place/topograph"
	"github.com/golang/glog"
)

// PlaceTopoQuerier implements interface of place.TopoQuerier based on pre-build connectivity data.
type PlaceTopoQuerier struct {
	stationLocationQuerier   place.LocationQuerier
	stationConnectivity      *topograph.MemoryTopoGraph
	reachableStationsByStart []*entity.TransferInfo
	reachableStationToEnd    map[entity.PlaceID]*entity.TransferInfo
	startLocation            *nav.Location
	endLocation              *nav.Location
}

// New creates place.TopoQuerier interface which is implemented by PlaceTopoQuerier
func New(stationFinder place.Finder, stationRanker place.Ranker,
	stationLocationQuerier place.LocationQuerier,
	stationConnectivity *topograph.MemoryTopoGraph,
	start, end *nav.Location,
	currEnergyLevel, maxEnergyLevel float64) place.TopoQuerier {

	querier := &PlaceTopoQuerier{
		stationLocationQuerier: stationLocationQuerier,
		stationConnectivity:    stationConnectivity,
		startLocation:          start,
		endLocation:            end,
	}
	querier.connectStartIntoStationGraph(stationFinder, stationRanker, start, currEnergyLevel)
	querier.connectEndIntoStationGraph(stationFinder, stationRanker, end, maxEnergyLevel)

	glog.Info("Generate PlaceTopoQuerier.\n")
	return querier
}

func (querier *PlaceTopoQuerier) connectStartIntoStationGraph(stationFinder place.Finder, stationRanker place.Ranker,
	start *nav.Location, currEnergyLevel float64) {
	center := nav.Location{Lat: start.Lat, Lon: start.Lon}
	nearByPoints := stationFinder.FindNearByPlaceIDs(center, currEnergyLevel, place.UnlimitedCount)
	rankedPoints := stationRanker.RankPlaceIDsByShortestDistance(center, nearByPoints)

	querier.reachableStationsByStart = rankedPoints
	glog.Infof("Add %d stations connects Start.\n", len(querier.reachableStationsByStart))
}

func (querier *PlaceTopoQuerier) connectEndIntoStationGraph(stationFinder place.Finder, stationRanker place.Ranker,
	end *nav.Location, maxEnergyLevel float64) {
	center := nav.Location{Lat: end.Lat, Lon: end.Lon}
	nearByPoints := stationFinder.FindNearByPlaceIDs(center, maxEnergyLevel, place.UnlimitedCount)
	rankedPoints := stationRanker.RankPlaceIDsByShortestDistance(center, nearByPoints)

	reachableStationToEnd := make(map[entity.PlaceID]*entity.TransferInfo)
	for _, rankedPointInfo := range rankedPoints {
		reachableStationToEnd[rankedPointInfo.ID] = &entity.TransferInfo{
			PlaceWithLocation: entity.PlaceWithLocation{
				ID:       iteratortype.DestLocationID,
				Location: end,
			},
			Weight: rankedPointInfo.Weight,
		}
	}

	querier.reachableStationToEnd = reachableStationToEnd
	glog.Infof("Add %d stations connects End node.\n", len(querier.reachableStationToEnd))
}

// GetConnectedPlaces finds near by stations by given placeID and return them in recorded sequence
// Returns nil if given placeID is not found or no connectivity
// For start point, directly returns reachableStationsByStart which is generated by considering current energy level.
// For end point, return nil, no connectivity expected from end to others
// For charge stations, it retrieves connectivity from pre-build data.  If a charge station is reachable to destination/end point, it must connects that into graph.
func (querier *PlaceTopoQuerier) GetConnectedPlaces(placeID entity.PlaceID) []*entity.TransferInfo {

	if placeID == iteratortype.OrigLocationID {
		return querier.reachableStationsByStart
	}

	if placeID == iteratortype.DestLocationID {
		return nil
	}

	if connectivityResults, ok := querier.stationConnectivity.QueryConnectivity(placeID); ok {
		if !querier.isStationConnectsToEnd(placeID) {
			return connectivityResults
		} else {
			size := len(connectivityResults) + 1
			results := make([]*entity.TransferInfo, 0, size)
			for _, result := range connectivityResults {
				results = append(results, result)
			}
			return querier.connectEndIntoGraph(placeID, results)
		}
	} else {
		// end position just find one charge station, and this charge station didn't has other conductivities.
		// this only exists theoretically or in mock environment
		if querier.isStationConnectsToEnd(placeID) {
			results := make([]*entity.TransferInfo, 0, 1)
			return querier.connectEndIntoGraph(placeID, results)
		}
	}

	return nil
}

// GetLocation returns location of given station id
// Returns nil if given placeID is not found
func (querier *PlaceTopoQuerier) GetLocation(placeID entity.PlaceID) *nav.Location {
	switch placeID {
	case iteratortype.OrigLocationID:
		return querier.startLocation
	case iteratortype.DestLocationID:
		return querier.endLocation
	default:
		return querier.stationLocationQuerier.GetLocation(placeID.String())
	}
}

func (querier *PlaceTopoQuerier) isStationConnectsToEnd(placeID entity.PlaceID) bool {
	_, ok := querier.reachableStationToEnd[placeID]
	return ok
}

func (querier *PlaceTopoQuerier) connectEndIntoGraph(placeID entity.PlaceID, results []*entity.TransferInfo) []*entity.TransferInfo {
	if queryResult4End, ok := querier.reachableStationToEnd[placeID]; ok {
		return appendIntoSortedSlice(queryResult4End, results)
	}
	return results
}

func appendIntoSortedSlice(item *entity.TransferInfo, results []*entity.TransferInfo) []*entity.TransferInfo {

	// todo @codebear801 this code assumes result is sorted by Distance, better hide in array itself or sortStrategy
	insertIndex := sort.Search(len(results), func(i int) bool {
		return results[i].Weight.Distance > item.Weight.Distance
	})

	results = append(results, nil)
	copy(results[insertIndex+1:], results[insertIndex:])
	results[insertIndex] = item

	return results
}
